extends Visitor;
includes Buf, Context;
native Tonyu;
native Worker;
native $;
native asmWorker;
native Uint8Array;
let worker;//=asmWorker;//new Worker("https://edit.tonyu.jp/cgi-bin/main.js?"+rnd());
let workerURL="https://hoge1e3.github.io/msx/asmWorker.js";
//let workerURL="https://edit.tonyu.jp/cgi-bin/asmWorker.js?"+rnd();
$.getScript(workerURL).then \(r) {
    worker=asmWorker;
};

initModule();
x=256;y=20;fillStyle="black";
let IDEPrj=$currentProject.compiler;
text="get Nodes...";
size=20;
let anodes=waitFor(IDEPrj.serializeAnnotatedNodes());
//print(anodes);
let mem=new MemberScan{genasm:this};
waitEvent(mem,"complete");
let lval=false;
let symSeq=1;
let ide=$Boot.getIDE();
let klass, klassSrc;
let problems=[];
let builtins={getkey:"getkey",rnd:"rnd"};
let globalVars={};
let locals={};
let params={};
let members;
let myMeth=new MyMeth{g:this};
let lbexit="lbexit";
let keynames={space: 0x0108, 
    right:0x8008,down:0x4008,up:0x2008,left:0x1008,
    w:0x1005,a:0x4002,s:0x0105,d:0x0203,t:0x0205,
    //;  rdul
    j1_right:0x800b, j1_down:0x400b, j1_up: 0x200b,j1_left:0x100b,
    j1_trig1: 0x010b, j1_trig2: 0x020b,
    j2_right:0x800c, j2_down:0x400c, j2_up: 0x200c,j2_left:0x100c,
    j2_trig1: 0x010c, j2_trig2: 0x020c,
};
let closestBrk;
//let mainClass;
//debug=true;

printf(`org 08000h
include z_tnu
include z_map
include z_bool
include z_dac
include z_mus
;include z_mzo


`);
let anode;
\annotation(n) {
    let res=anode[n._id];
    if (!res) {
        return {};
    }
    return res;
}
function isConst(n){
    return annotation(n).constVal;
}
function deable(n) {
    //return false;
    return isConst(n)||
    n.type=="varAccess";
}
let outp=new OutPat;
let outbg=new OutBG;

let hasMain;
for (klass of mem.ks) {
    let r=mem.objRange(klass);
    text=klass.shortName;
    if (text===$mainClassName) {
        hasMain=true;
        printf("_main:%ntnu.run %s,%d,%d%n",$mainClassName,r[0],r[1]);
    }
    printf("; class_def_start %s%n",klass.shortName);
    printf(";range %d-%d%n",r[0],r[1]);
    mem.header(klass);
    klassSrc=klass.src.tonyu.text();
    let methods=klass.decls.methods;
    anode=(klass.annotation);
    for (let mname, me of methods) {
        let method:FuncInfo=me;
        
        text=klass.shortName+"."+mname;
        params={};
        let ln=1;
        for (let i,pa of method.params) {
            params[pa.name.text]=ln;
            ln++;
        }
        locals={};
        ln=1;
        for (let k,v of method.locals.varDecls) {
            // v:VarDecl|Forin|Catch|Token (See definition of SemCtx)
            locals[k]=ln;
            ln++;
        }
        members=mem.getMembers(klass);
        new ConstVisitor().collect(
        klass,method);
        
        printf("def %s.%s,%d,%d%{",
        klass.shortName, mname, 
        method.params.length,
        Object.keys(locals).length);
        printf("#local%n");
        for(let s of method.stmts) visit(s);
        printf("%s:%n#endlocal%n",lbexit);
        printf("enddef %s.%s%n", klass.shortName, mname);
        printf("%}");
        update();
    }
    printf("; class_def_end %s%n",klass.shortName);
    update();
}
if (!hasMain) throw new Error(`Main class ${$mainClassName} is not subclass of RActor`);
text="Writing assets...";
while(!outp.complete || !outbg.complete) update();

\dataSection(type, array) {
    let perline=16;
    for (let i=0;i<array.length;i++) {
        if (i%perline==0) {
            printf("%s ",type);
        }
        printf("%d",array[i]);
        if ((i+1)%perline==0 || i==array.length-1) {
            printf("%n");
        } else {
            printf(", ");
        }
    }
    return "";
}
printf(";!ROM%n");
for (let k of Object.keys($MZO.arrays)) {
    printf("%s: dw $+2%n",globalLabel(k));
    dataSection("db", Array.from($MZO.arrays[k]));
}
printf(";!/ROM%n");
printf(`
${Object.keys($config.intArrays||{}).map \(k) {
    let i= $config.intArrays[k];
    if (typeof i==="number") {
        return globalLabel(k)+":dw $+2\n"+
        "ds "+(i*2);
    } else {
        // 1-d array only currently
        return globalLabel(k)+":dw $+2\n"+
        "dw "+i.join(", ");
    }
}.join("\n")};
${Object.keys(globalVars).map \(k){
    if ($MZO.arrays[k]) return "";
    if ($config.consts[k]) return "";
    if ($config.intArrays[k]) return "";
    return globalLabel(k)+":dw 0";
}.join("\n")}
endusr:
;!ROM
inivrm macro n, dst
 ld de,&dst
 ld hl,&n
 ld bc,end.&n-&n
 call LDIRVM
endm

spr.inipat:
 inivrm spr.pat, 3800h
 ret

spr.pat:
${outp.buf}
end.spr.pat:

bg.inipat:
 inivrm bg.gen, 0000h
 inivrm bg.gen, 0800h
 inivrm bg.gen, 1000h
 inivrm bg.col, 2000h
 inivrm bg.col, 2800h
 inivrm bg.col, 3000h
 inivrm bg.name, 1800h
 ret

bg.gen:
${toDB(outbg.patgen)}
end.bg.gen:

bg.col:
${toDB(outbg.coltbl)}
end.bg.col:

bg.name:
 ds 256*3,32
end.bg.name:
;!/ROM

end _main`);

if (problems.length) {
    let tx=new HTMLUI{
        content:["div",
        {style:'background: #fee;'},
        ["h2","Problem(s) found"],
        ["ul"].concat(
        problems.map\(p) {
            return ["li",["a",{
                href:"javascript:;",
                onclick: \{
                    ide.jump(p.file, p.row, p.col);  
                }
            },
            p.file.name(),":",p.row,":",p.col," - ",p.mesg
            ]];
        }),
        ["button",{onclick:\{tx.die();}},"Close"]
        ],
        left:10, top: 20, width:300,
        height:400,
    };
    return;
}
/*print(Object.keys(n.decls.fields));
print(n.superclass.fullName);
*/
//print("buf="+buf);
let url_pen="https://msxpen.com/codes/-N8klu22ZKY0trVaYX66";
let url_ws="https://8bitworkshop.com/v3.10.0/?platform=msx";
let export_platforms={
    msxpen:["ul",
    ["li",
    "Open ",
    ["a",{target:"pen",href:url_pen},
    "this MSXpen page "],
    "."],
    ["li","Paste the copied code",
    " to 'Asm' tab."]],
    "8bitws":["ul",
    ["li",
    "Open ",
    ["a",{target:"ws",href:url_ws},
    "the 8bitworkshop ide"],
    "."],
    ["li","Paste the copied code"]],
};
//msxpen.com/codes/-N8kjRrkOlaH4vlLV7MY";


//msxpen.com/codes/-N8kZzjv3KL0vbHvgiqT";
let cg=new Includer;
let included=cg.gensrc(buf+"").replace(/\r/g,"");
outAsm("macro.ram", included);
text="Loading assembler...";
while(!worker) update();
text="Assemble in progress...";
worker.postMessage( included );
let plain=runPromise \(s,err){
    \f(e) {
        worker.removeEventListener("message",f); 
        let data=$JSON.parse(e.data);
        if (data.type==="error") err(new Error(data.message));
        else s(data.result);
    }
    worker.addEventListener("message",f);
};
text="";
plain=plain.map\(e){return e.body;}.join("\n");
outAsm("plain.ram", plain);


switch ($config.postprocess.target) {
    case "rom":
    dlROM();break;
    case "msxpen":
    case "8bitws":
    showDiag{platform:$config.postprocess.target};
    break;
    default:
    new Button{top:420,left:50, width:200,height:25,
        text:"to MSXPen",platform:"msxpen",padding:1,
    onClick:showDiag,fillStyle:$RSprPat.palette[4]};
    new Button{top:420,left:300, width:200,height:25,
        text:"to 8bitworkshop",platform:"8bitws",padding:1,
    onClick:showDiag,fillStyle:$RSprPat.palette[9]};
    new Button{top:445,left:50, width:200,height:25,
        text:"Download ROM",padding:1,
    onClick:dlROM,fillStyle:$RSprPat.palette[13]};
}
//new Button{top:420,text:"to MSXPen",onClick:showDiag,fillStyle:$RSprPat.palette[2]};
\toDB(bytes) {
    let buf="",c=[];
    while(bytes.length) {
        let b=bytes.shift();
        c.push("0"+b.toString(16)+"h");
        if (c.length>=8) {
            buf+="db "+c.join(", ")+"\n";
            c=[];
        }
    }
    if (c.length) buf+="db "+c.join(", ")+"\n";
    return buf;
}
\showDiag(b) {
    //msxpen.com/codes/-N8fnpcspSXEqEJ4lOeO";
    
    let tx;
    if (!$config.postprocess.noDialog) tx=new HTMLUI{
        content:["div",
        {style:'background: #eee;'},
        ["h2","Code copied!"],
        export_platforms[b.platform],/*
        ["ul",
        ["li",
        "Open ",
        ["a",{target:"pen",href:url_pen},
        "this MSXpen page "],
        "."],
        ["li","Paste the copied code",
        " to 'Asm' tab."]],*/
        ["textarea",{rows:"10", cols:"30",name:"val"},
        "test\ndesu"],
        ["button",{onclick:\{tx.die();}},"Close"]
        ],
        left:10, top: 20, width:300,
        height:400,
    };
    let generatedAsm;
    if (b.platform==="8bitws") {
        generatedAsm=new GenROM{base:this}.gen(plain);
    } else {
        let cg=new Includer;
        generatedAsm=plain;
    }
    if (tx) {
        tx.setValue("val", generatedAsm);
        tx.copyToClipboard("val");
    }
    if (typeof $config.postprocess.onExport==="function") {
        $config.postprocess.onExport{asm:generatedAsm};
    }
}
\dlROM() {
    let romAsm=new GenROM{base:this}.gen(plain);
    \f(e) {
        worker.removeEventListener("message",f);
        let data=$JSON.parse(e.data);
        if (data.type==="error") {return print(data.message);}
        let bins=[];
        for (let line of data.result) {
            for (let e of line.bin) bins.push(e);
        }
        while(bins.length<0x8000) bins.push(0);
        //print(bins);
        let romFile=file($config.postprocess.romFileName || "output.rom");
        romFile.setBytes(new Uint8Array(bins));
        if (typeof $config.postprocess.onExport==="function") {
            $config.postprocess.onExport{romFile};
        } else {
            romFile.download();
        }
    }
    worker.addEventListener("message",f);
    worker.postMessage( romAsm );
}
\def(n){
    if(!n){
        throw new Error("Visited undefined");
        print(n);
        return;
    }
    print(n.type,":",
    Object.keys(n));
    unsup(n);
}

\globalLabel(n:String) {
    return `gbl_${n.replace(/\$/g,"")}`;
}
\unsup(n:TNode, mesg:String) {
    mesg=mesg|| "Unsupported syntax";
    let file=klass.src.tonyu;
    let rc=Tonyu.TError.calcRowCol(klassSrc,n.pos);
    let p={file, row:rc.row, col: rc.col, mesg};
    problems.push(p);
    //ide.jump( file, rc.row, rc.col);
    print(p.file.name(),":",p.row,":",p.col," - ",p.mesg);
}
\outAsm(name, content) {
    if ($Navigator.isNW()) {
        file(`asm/${name}.asm`).text(content);
    }
}