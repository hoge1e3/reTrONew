extends Visitor;
includes Buf, Context;
native Tonyu;
initModule();
x=256;y=20;fillStyle="black";
let IDEPrj=$currentProject.compiler;
text="get Nodes...";
let anodes=waitFor(IDEPrj.serializeAnnotatedNodes());
//print(anodes);
let mem=new MemberScan{genasm:this};
waitEvent(mem,"complete");
let lval=false;
let symSeq=1;
let ide=$Boot.getIDE();
let klass, klassSrc;
let problems=[];
let builtins={getkey:"getkey",rnd:"rnd"};
let globals={};
let locals={};
let params={};
let myMeth=new MyMeth{g:this};
let lbexit="lbexit";
let keynames={space: 0x0108, 
    right:0x8008,down:0x4008,up:0x2008,left:0x1008,
    w:0x1005,a:0x4002,s:0x0105,d:0x0203,
    //;  rdul
    j1_right:0x800b, j1_down:0x400b, j1_up: 0x200b,j1_left:0x100b,
    j1_trig1: 0x010b, j1_trig2: 0x020b,
    j2_right:0x800c, j2_down:0x400c, j2_up: 0x200c,j2_left:0x100c,
    j2_trig1: 0x010c, j2_trig2: 0x020c,
};
let closestBrk;
//let mainClass;
//debug=true;
let opmap={
    "*":"call IMULT.a%n", 
    "/":"call IDIV.a%n",
    "%":"call IMOD.a%n",
    "+":"add hl, de%n",
    "-":"subhl de%n",
};

printf(`org 08000h
include tnu
include map
include bool
include dac
include mus


`);
let anode;
\annotation(n) {
    let res=anode[n._id];
    if (!res) {
        return {};
    }
    return res;
}
for (klass of mem.ks) {
    let r=mem.objRange(klass);
    text=klass.shortName;
    if (text===$mainClassName) {
        printf("main:%ntnu.run %s,%d,%d%n",$mainClassName,r[0],r[1]);
    }
    //print("KLS",klass);
    printf(";range %d-%d%n",r[0],r[1]);
    mem.header(klass);
    klassSrc=klass.src.tonyu.text();
    //print(klass.src.tonyu);
    let methods=klass.decls.methods;
    anode=(klass.annotation);
    //let fldc=(new FldCollect{anode});
    //print("FLDC", fldc, fldc.visit);
    for (let mname, me of methods) {
        let method:FuncInfo=me;
        
        text=klass.shortName+"."+mname;
        //print(text);
        //fldc.visit(method.stmts);
        params={};
        let ln=1;
        for (let i,pa of method.params) {
            params[pa.name.text]=ln;
            ln++;
        }
        locals={};
        ln=1;
        for (let k,v of method.locals.varDecls) {
            /*if (!v.name) {
                print("V.name", k,v,method.locals.varDecls);
            }*/
            // v:VarDecl|Forin|Catch|Token (See definition of SemCtx)
            locals[k]=ln;
            ln++;
        }
        //if (Object.keys(locals).length) print("LOCAL",locals);
        /*if (method.params.length>0) {
            unsup(method.params[0],"Parameters is not yet supported");
        }*/
        //print(method.locals.varDecls);
        printf("def %s.%s,%d,%d%{",
        klass.shortName, mname, 
        method.params.length,
        Object.keys(locals).length);
        printf("proc%nlocal %s%n",lbexit);
        for(let s of method.stmts) visit(s);
        printf("%s:%nendp%n",lbexit);
        printf("enddef %s.%s%n", klass.shortName, mname);
        printf("%}");
        update();
    }
    update();
}
text="";
let outp=new OutPat;
let outbg=new OutBG;
waitEvent(outbg,"complete");

printf(`
${Object.keys($MZO.arrays).map \(k) {
    return globalLabel(k)+":dw $+2\n"+
    "db "+Array.from($MZO.arrays[k]).join(", ")+"\n";
}.join("\n")}
${Object.keys(globals).map \(k){
    if ($MZO.arrays[k]) return "";
    if ($config.intArrays && $config.intArrays[k]) {
        let i= $config.intArrays[k];
        if (typeof i==="number") {
            return globalLabel(k)+":dw $+2\n"+
            "ds "+(i*2);
        } else {
            // 1-d array only currently
            return globalLabel(k)+":dw $+2\n"+
            "dw "+i.join(", ");
        }
    } else {
        return globalLabel(k)+":dw 0";
    }
}.join("\n")}
endusr:
macro inivrm, n, dst
 ld de,dst
 ld hl,n
 ld bc,end.##n-n
 call LDIRVM
endm

spr.inipat:
 inivrm spr.pat, 3800h
 ret

spr.pat:
${outp.buf}
end.spr.pat:

bg.inipat:
 inivrm bg.gen, 0000h
 inivrm bg.gen, 0800h
 inivrm bg.gen, 1000h
 inivrm bg.col, 2000h
 inivrm bg.col, 2800h
 inivrm bg.col, 3000h
 inivrm bg.name, 1800h
 ret

bg.gen:
${toDB(outbg.patgen)}
end.bg.gen:

bg.col:
${toDB(outbg.coltbl)}
end.bg.col:

bg.name:
 ds 256*3,32
end.bg.name:

end main`);
/*print(Object.keys(n.decls.fields));
print(n.superclass.fullName);
*/
//print("buf="+buf);
let url="https://msxpen.com/codes/-N8klu22ZKY0trVaYX66";

//msxpen.com/codes/-N8kjRrkOlaH4vlLV7MY";


//msxpen.com/codes/-N8kZzjv3KL0vbHvgiqT";


new Button{top:420,text:"to MSXPen",onClick:showDiag,fillStyle:$RSprPat.palette[2]};
\toDB(bytes) {
    let buf="",c=[];
    while(bytes.length) {
        let b=bytes.shift();
        c.push("0"+b.toString(16)+"h");
        if (c.length>=8) {
            buf+="db "+c.join(", ")+"\n";
            c=[];
        }
    }
    if (c.length) buf+="db "+c.join(", ")+"\n";
    return buf;
}
\showDiag() {
    //msxpen.com/codes/-N8fnpcspSXEqEJ4lOeO";
    if (problems.length) {
        let tx=new HTMLUI{
            content:["div",
            {style:'background: #fee;'},
            ["h2","Problem(s) found"],
            ["ul"].concat(
            problems.map\(p) {
                return ["li",["a",{
                    href:"javascript:;",
                    onclick: \{
                        ide.jump(p.file, p.row, p.col);  
                    }
                },
                p.file.name(),":",p.row,":",p.col," - ",p.mesg
                ]];
            }),
            ["button",{onclick:\{tx.die();}},"Close"]
            ],
            left:10, top: 20, width:300,
            height:400,
        };
        return;
    }
    let tx=new HTMLUI{
        content:["div",
        {style:'background: #eee;'},
        ["h2","Code copied!"],
        ["ul",
        ["li",
        "Open ",
        ["a",{target:"pen",href:url},
        "this MSXpen page "],
        "."],
        ["li","Paste the copied code",
        " to 'Asm' tab."]],
        ["textarea",{rows:"10", cols:"30",name:"val"},
        "test\ndesu"],
        ["button",{onclick:\{tx.die();}},"Close"]
        ],
        left:10, top: 20, width:300,
        height:400,
    };
    if (getkey("n")) {
        tx.setValue("val", buf+"");
    } else {
        let cg=new Includer;
        tx.setValue("val", cg.gensrc(buf+""));
    }
    tx.copyToClipboard("val");
}

\def(n){
    if(!n){
        throw new Error("Visited undefined");
        print(n);
        return;
    }
    print(n.type,":",
    Object.keys(n));
    unsup(n);
}

\globalLabel(n:String) {
    return `gbl_${n.replace(/\$/g,"")}`;
}
\unsup(n:TNode, mesg:String) {
    mesg=mesg|| "Unsupported syntax";
    let file=klass.src.tonyu;
    let rc=Tonyu.TError.calcRowCol(klassSrc,n.pos);
    let p={file, row:rc.row, col: rc.col, mesg};
    problems.push(p);
    //ide.jump( file, rc.row, rc.col);
    print(p.file.name(),":",p.row,":",p.col," - ",p.mesg);
}