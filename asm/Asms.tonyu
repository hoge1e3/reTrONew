extends TObject;
let data={'z_main':`org 09000h
; TODO
; frameCount
; strig

include z_ctrl
include z_math
include z_debug
include z_sub
include z_mem
include z_sp
include z_vdp
include z_th


;===your code

main:
ld a,5
lp:
dec b
show a
iff nc,nx
jr lp
nx:

ret
end main`,
    'z_math':`include z_ctrl

;16bit shifts
slhl macro xx
 sla l
 rl h
endm
srahl macro xx
 sra h
 rr l
endm
srlhl macro xx
 srl h
 rr l
endm
slde macro xx
 sla e
 rl d
endm
srade macro xx
 sra d
 rr e
endm
srlde macro xx
 srl d
 rr e
endm
slbc macro xx
 sla c
 rl b
endm
srabc macro xx
 sra b
 rr c
endm
srlbc macro xx
 srl b
 rr c
endm


; for xrnd
sldehl macro n
#local
  ld b,&n
 loop:
  sla d
  rl e
  rl h
  rl l
  djnz loop
#endlocal
endm
srdehl macro n
#local
 ld b,&n
 loop:
  srl l
  rr h
  rr e
  rr d
 djnz loop
#endlocal
endm

xorrm macro re,me
  ld A,(&me)
  xor &re
  ld (&me),a
endm

subhl macro rp
 and a
 sbc hl,&rp
endm

cpde.a macro n
 rst dcompr
endm

defwork xrnd.seed
 dw 1234
 dw 5678
endwork xrnd.seed

defsub xrnd.a
; h l d e
 ld hl,(xrnd.seed+2)
 ld de,(xrnd.seed)
 ; s[0] ^= s[0] << 13
 push de
 pop bc
; h l d e
; b c
 ld a,l
 rept 3
  srl a
  rr b
  rr c
 endm
 ld a,h
 xor b
 ld h,a
 ld a,l
 xor c
 ld l,a
 ; s[0] ^= s[0] >> 17
 
 push hl
 pop bc
; h l d e
;     b c
 srl b
 rr c
 
 ld a,d
 xor b
 ld d,a
 ld a,e
 xor c
 ld e,a

 ; s[0] ^= s[0] << 5;
 ; h l d e
 ;   b c
 ld b,l
 ld c,d
 ld a,e
 rept 3
  srl a
  rr b
  rr c
 endm

 ld a,l
 xor b
 ld l,a
 ld a,d
 xor c
 ld d,a
 
 ld (xrnd.seed+2),hl
 ld (xrnd.seed),de

 ret
endsub xrnd.a


defsub rnd
 push af
 call rnd.a
 pop af
endsub rnd

defsub rnd.a
 ex de,hl
 ld hl,07fffh
 call udiv.a
 inc bc
 push bc
 call xrnd.a
 res 7,h
 pop de
 call udiv.a
 ld h,b
 ld l,c
endsub rnd.a

defsub abs
 bit 7,h
 ret z
neghl:
 ld de,0
 ex de,hl
 subhl de
 ret
endsub abs

defsub clamp
#local
 ; hl value
 ; bc min
 ; de max
 push hl
 subhl bc
 bit 7,h
 pop hl
 jr z, notmin
  ld h,b
  ld l,c
  ret
 notmin:
 push hl
 subhl de
 bit 7,h
 pop hl
 ret nz
 ex de,hl
 ret
#endlocal
endsub clamp

defsub mul.a
 ; hl*=de
#local
 ld b,h
 ld c,l
 
 ld hl,0
loop:
 srlbc 0
 jr nc,notad
 add hl,de
notad:
 slde 0
 ld a,b
 or c
 jr nz,loop
 
#endlocal
endsub mul.a

defsub log.a
#local
 push hl
 ld a,16
loop:
 dec A
 slhl 0
 jr nc,loop
 pop hl
#endlocal
endsub log.a

neghl.sv macro xx
 push de
 call neghl
 pop de
endm
negde.sv macro xx
 ex de,hl
 neghl.sv 0
 ex de,hl
endm
defsub div.a
; hl/=de with signed
; de=remainder
#local
 ld a,0
 ; hl=abs(hl), 
 ; a++ if hl<0
 bit 7,h
 jr z, hposi
 xor 3
 neghl.sv 0
hposi:
 ; de=abs(de), 
 ; a++ if de<0
 bit 7,d
 jr z, dposi
 xor 1
 negde.sv 0
dposi:
 push af
 call udiv.a
 ex de,hl; remainder
 ld h,b
 ld l,c
 pop af
 bit 0,a
 jp z, nnq
; negate quotient
 neghl.sv 0
nnq:
 bit 1,a
 jp z, nnr
; negate remainder
 negde.sv 0
nnr:
 
#endlocal
endsub div.a

defsub udiv.a
 ; bc=hl/de
 ; hl=hl%de
#local
 ld a,d
 or e
 ret z; /0 error
 
 ld b,0
bitc.lp:
 slde 0
 inc b
 rst dcompr
 jr nc, bitc.lp
bitc.br:
 srlde 0
 ld a,b
 ld bc,0
 ;ld (hexval),de
 ;call showhex
put.lp:
 subhl de
 bit 7,h
 jr z, put1
put0:
 add hl,de
 and a
 jr puten
put1:
 and a
 scf  
puten:
 rl c
 rl b
 srlde 0
 dec a
 jr nz, put.lp 
put.br:

#endlocal
endsub udiv.a

`,
    'z_bool':`include z_math
include z_ctrl
true equ -1
false equ 0

ret.true.if macro flg
#local
 iff &flg ,tru
  ld hl,true
  ret
 tru:
#endlocal
endm

ret.false.if macro flg
#local
 iff &flg ,tru
  ret.false
 tru:
#endlocal
endm

ret.false macro
 ld hl,false
 ret
endm

hleqde:
 subhl de
 ret.true.if z
 ret.false

hlnede:
 subhl de
 ret.true.if nz
 ret.false

hlgtde:
 subhl de
 ret.false.if z
 bit 7,h
 ret.true.if z
 ret.false

hlltde:
 subhl de
 bit 7,h
 ret.true.if nz
 ret.false

hlgede:
 subhl de
 ret.true.if z
 bit 7,h
 ret.true.if z
 ret.false

hllede:
 subhl de
 ret.true.if z
 bit 7,h
 ret.true.if nz
 ret.false

ziffalse:
#local
 ld (resa-1),a
 call ziffalse.a
 ld A,0
 resa:
 ret
ziffalse.a:
 ld a,0
 cp h
 ret nz
 cp l
 ret
#endlocal

jpf macro to
 call ziffalse
 jp z,&to
endm

andand macro fls
 jpf &fls
endm
oror macro tru
 call ziffalse
 jp nz,&tru
endm

bitand.a macro xx
 ; hl&=de
 ld a,h
 and d
 ld h,a
 ld a,l
 and e
 ld l,a
endm

bitor.a macro xx
 ; hl|=de
 ld a,h
 or d
 ld h,a
 ld a,l
 or e
 ld l,a
endm


flagtobool macro fl
#local
 jr &fl, yes
 ld hl,false
 jr skp
 yes:
 ld hl,true
 skp:
#endlocal
endm

defsub nothl
#local
 jpf fls
 ld hl, false
 ret
 fls:
 ld hl, true
#endlocal
endsub nothl
`,
    'z_mem':`include z_const
;
rdslt:
 ex de,hl
 rept 5
 srl d;page*2
endm
 CALL RSLREG
 ld e,d
 rdslt1:
  RRCA
  dec e
  jp nz,rdslt1
 AND    00000011B
 LD c,A;000000Pr
 LD B,0
 LD HL,EXPTBL
 ADD HL,BC
 LD c,A;000000Pr
 LD A,(HL)
 AND 80H;expand flag
 OR c
 LD c,A;e00000Pr
 rept 4;const
 INC HL
endm
 LD A,(HL);exp reg
 ld e,d
 rdslt2:
  srl a
  dec e
  jp nz,rdslt2
;000000Ex
 sla a
 sla a
 ;    0000Ex00
 and  00001100b
 OR c;e000ExPr
 ret
memini:
 CALL RSLREG
 rept 4
  RRCA
endm
 AND    00000011B
 LD c,A;000000Pr
 LD B,0
 LD HL,EXPTBL
 ADD HL,BC
 LD c,A;000000Pr
 LD A,(HL)
 AND 80H;expand flag
 OR c
 LD c,A;e00000Pr
 rept 4;const
 INC HL
endm
 LD A,(HL);exp reg
 rept 4; page*2
 srl a
endm;000000Ex
 sla a
 sla a
 ;    0000Ex00
 and  00001100b
 OR c;e000ExPr
 LD Hl,04000H
 jp ENASLT

peekw macro regv,regm
#local
  ld (w-2),&regm
  ld &regv,(0)
  w:
#endlocal
endm

pokew macro regm,regv
#local
  ld (w-2),&regm
  ld (0),&regv
  w:
#endlocal
endm
movw macro dst,src
 push hl
 ld hl,&src
 ld &dst,hl
 pop hl
endm

popa macro xx
  ex (sp),hl
  ld a,h
  pop HL
endm

pushall macro
 push af
 push bc
 push de
 push hl
endm
popall macro
 pop hl
 pop de
 pop bc
 pop af
endm


pushi macro n,rp
 ld &rp,&n
 push &rp
endm
const macro n,reg
 ld (&n-2),&reg
endm
ldconst macro reg,n
 ld &reg,0
 &n:
endm
peekconst macro reg,n
 ld &reg,(0)
 &n:
endm
`,
    'z_const':`
;wrt equ 0a2h
dcompr equ 0020H

sp.ini.h  equ 0dch
sp.ini    equ sp.ini.h*256
stksize.h equ 2
stksize   equ stksize.h*256

th.size.h   equ 1
th.size     equ th.size.h*256
th.count    equ 20
th.end.h    equ sp.ini.h-stksize.h
th.end      equ th.end.h*256
th.start.h  equ th.end.h-th.count*th.size.h
th.start    equ th.start.h*256


th.bottom equ 0

spr.scale equ 1
spr.xmax equ 256<<spr.scale
spr.ymax equ 192<<spr.scale

ENASLT EQU 0024H
RSLREG EQU 0138H
EXPTBL EQU 0FCC1H
SETWRT equ 0053H
LDIRVM equ 005CH
WRTVDP equ 0047H
RG1SAV equ 0F3E0H
RDVDP  equ 013EH
SNSMAT.a equ 0141h

CHGMOD equ 005FH

IMULT.a equ 3193H;HL ← DE*HL
IDIV.a equ 31E6H;HL ← DE/HL
IMOD.a equ 323AH;HL ← DE mod HL (DE ← DE/HL)

WRTPSG  equ 0093H

CSRY equ 0F3DCH
CSRX equ 0F3DDH

null equ 0

marker.b macro n
 ;last.marker: defl $
endm
marker.e macro n
 ;len.##n: defl $-last.marker
endm
`,
    'z_ctrl':`include z_const
freeze:
halt
jr freeze

for macro lbend
 ; uses a
 ; c: breaked
#local
  lb:
  call dcompr; uses a
  jp nc,&lbend
  push HL
  push de
  push bc
  call s
  pop bc
  pop de
  pop HL
  jp c,&lbend
  add HL,bc
  jr lb
  s:
#endlocal
endm

repti macro n,lbend
#local
  push bc
  ld b,&n
  lb:
  push bc
  call s
  pop bc
  jr c,lbend2
  djnz lb
  lbend2:
  pop bc
  jp &lbend
  s:
#endlocal
endm


reptb macro lbend
#local
 inc b
 djnz lb
 jp &lbend
 lb:
  push bc
  call s
  pop bc
  jp c,&lbend
 djnz lb
 jp &lbend
 s:
#endlocal
endm



callsva macro pp
#local
 ld (sva-1),a
 call &pp
 ld a,0
 sva:
#endlocal
endm
bcis0:
 callsva bcis0.a
 ret
bcis0.a:
 ld a,b
 and a
 ret nz
 ld a,c
 and a
 ret

reptbc macro lbend
#local
 call bcis0
 jp z,&lbend
 lb:
  push bc
  call s
  pop bc
  jp c,&lbend
  dec bc
  call bcis0
 jr nz, lb
 jp &lbend
 s:
#endlocal
endm


iff.nz equ 0
iff.z  equ 1
iff.nc equ 2
iff.c  equ 3

iff macro cnd,to
 if iff.&cnd eq iff.nz
  jr z,&to
 endif
 if iff.&cnd eq iff.z
  jr nz,&to
 endif
 if iff.&cnd eq iff.nc
  jr c,&to
 endif
 if iff.&cnd eq iff.c
  jr nc,&to
 endif
 ;jr cnd, skip
 ;jr to
 ;skip:
endm

break macro
 scf
 ret
endm
break.if macro cnd
#local
 iff &cnd ,jj
  break
 jj:
#endlocal
endm

continue macro
 or a
 ret
endm
continue.if macro cnd
#local
 iff &cnd,jj
  continue
 jj:
#endlocal
endm


djnzr macro reg,j
 dec &reg
 jr nz,&j
endm

callhl macro
#local
 ld (LCD-2),HL
 call LCD
 LCD:
#endlocal
endm

stride macro lim,to
 if lo($)<&lim
  exitm
 endif
 ds 256+&to-lo($),0cdh
endm


unreach macro mesg
 ;trace mesg
 call h.unreach
endm
head macro lb
 unreach &lb
 marker.b &lb
 &lb:
endm

defsub macro n
 head &n
endm
endsub macro n
 ret
 marker.e &n
endm
defwork macro n
 head &n
endm
endwork macro n
 marker.e &n
endm

defsub h.unreach
 ld a,'u'
 ld hl,1800h
 call 4dh
 dw 0x18,0xfe
endsub h.unreach`,
    'z_th':`include z_ctrl
include z_sp
include z_vdp
include z_mem
include z_math
include z_debug

th.ofs.stp equ 256-4
th.ofs.sp equ th.ofs.stp+1
th.ofs.spini equ th.ofs.stp
fld.top equ th.ofs.spini-2
th.st.blank equ 0c9h
th.st.active equ 31h

;macro th.for,lb
; ld HL,th.start
; ld de,th.end
; ld bc,th.size
; for lb
;endm
th.for.a macro nx,st,en
#local
 ld a,&st+(th.start.h)
 loop:
  cp &en+(th.start.h)
  jp nc, &nx
  push af
  ld h,a
  ld l,0
  call do
  popa 0
  ld h,a
  ld l,0
  jp c, &nx
  inc a
 jr loop
 do:
#endlocal
endm

th.new.range macro st,en
 ld bc,&st
 ld(th.new.start),bc
 ld bc,&en
 ld(th.new.end),bc
endm

defsub th.isblank.a
 ; h= thread
 ; z if true
 ld l, th.ofs.stp
 ld a,(hl)
 cp th.st.blank
endsub th.isblank.a

 defwork th.new.start
 dw th.start
 endwork th.new.start
 defwork th.new.end
 dw th.end
 endwork th.new.end

defsub th.find.blank
; h: result  nz: not found
#local
 ld a,(th.new.start+1)
 ld h,a
 ld l,th.ofs.stp
loop:
 ld a,(hl)
 cp th.st.blank
 ret z
 ld a,(th.new.end+1)
 inc h
 cp h
 jr nz,loop
 inc a; reset z
#endlocal
endsub 0

defsub th.new
; nc for alloc fail
#local
 ld hl,(th.new.start)
 ld de,(th.new.end)
 ld bc,th.size
 for lbend
  ; TODO th.ofs.stp
  call th.isblank.a
  break.if z
  continue
 lbend:
 ret nc
 ; TODO th.ofs.stp
 ld L,th.ofs.stp
 ld (HL),31h
 inc HL
 ld (HL),th.ofs.spini
 ld a,h
 inc HL
 ld (hl),a
 inc HL
 ld (HL),0c9h
 ld l,th.bottom
 scf
 ret
#endlocal
endsub th.new

defsub th.init
#local
 th.for.a lbend, 0, th.count
  ; TODO th.ofs.stp
  ld L, th.ofs.stp
  ld (HL),th.st.blank
  continue
 lbend:
 ; disable timer
 ld HL,0fd9fh
 ld (hl),0c9h
 call susint
 ret
#endlocal
endsub th.init

defsub th.stepall
 th.for.a thnx, 0, th.count
  ;todo th.ofs.stp
  ld (th.cur),hl
  call th.isblank.a
  continue.if z
  call th.step

  ; chk reserved kill
  ld hl,0
  ld (th.cur),hl
  ld a,(th.kill.reserve)
  cp 0
  continue.if z
  ld h,a
  call th.kill.a
  xor a
  ld (th.kill.reserve),a
  continue
 thnx:
endsub th.stepall

defsub th.kill.a
; th.term = self kill
; th.kill = kill from either external or internal
#local
 ; h: th
 ld a,(th.cur+1)
 cp h
 jr z, reserve
  ld l, th.ofs.stp
  ld (hl), th.st.blank
  ret
 reserve:
  ld (th.kill.reserve),a
#endlocal
endsub th.kill.a

defwork th.kill.reserve
db 0
endwork th.kill.reserve

defsub th.step
 ld (adrssp+1),sp
 ld HL,(th.cur)
 ld l,th.ofs.stp
 ;call susint
 jp (hl)
endsub th.step

defsub th.yield
 ld hl,(th.cur)
 ld l,th.ofs.sp
 sp2mem
 adrssp:
 ld sp,0
 jp doint
endsub th.yield

defsub th.term
 ld hl,(th.cur)
 ; TODO th.ofs.stp
 ld L,th.ofs.stp
 ld (hl),th.st.blank
 jr adrssp
endsub th.term

th.with.do macro to
#local
 th.with pr
 jr &to
 pr:
#endlocal
endm

th.with.setdst macro reg
 ld (th.jpdest-2),&reg
endm
th.with macro pr
 movw (th.jpdest-2), &pr
 call th.with.s
endm
th.with.ret macro n
 jp th.ewith
endm

defsub th.with.s
 ld (th.wrssp-2),sp
 ld l, th.ofs.sp
 ld (th.updsp-2),hl
 mem2sp
 jp 0
 th.jpdest:
th.ewith:
 ld (0),sp
 th.updsp:
 ld sp,0
 th.wrssp:
endsub th.with.s




defsub th.push
 ;push bc to thread hl
 th.with tpsbc
 ret
 tpsbc:
  push bc
  th.with.ret 0
endsub th.push


defwork th.cur
 dw 0
endwork th.cur

defsub th.loop
 ; hook before stepall
 db 0cdh
 h.thent:
 dw int.nop
 ; save prev timecnt
 ld a,(timecnt)
 push af
 ; Do stepall
 call th.stepall
 ; hook after stepall
 db 0cdh
 h.thlop:
 dw int.nop
 ; wait until timecnt changes
 pop af
 bwat:
  ld hl,timecnt
  cp (hl)
  jr nz,bbwat
  push af
  call doint
  pop af
  jr bwat
 bbwat:
 ; repeat
 jr th.loop
endsub th.loop



th.pushi macro val
 ld bc,&val
 call th.push
endm

`,
    'z_sub':``,
    'z_debug':`include z_math
include z_ctrl

;debug
show macro reg
 ld (hexval),&reg
 call showhex
endm
showm macro ad
 push hl
 ld HL,(&ad)
 show HL
 pop HL
endm
showlb macro lb
 push hl
 ld hl,&lb
 ld (hexval),hl
 call showhex
 pop hl
endm

trace macro v
 push af
 ld a,&v
 ld (trad),a
 pop af
 call trace.s
endm

defwork hexval
 dw 0
endwork hexval

defsub showhex
#local
 push af
 push bc
 push HL
 ld hl,(hexval)
 ld b,4
 loop:
  xor a
  rept 4
   slhl 0
   rla
endm
  call showhex1
 djnz loop
 ld a,32
 call wrt
 pop HL
 pop bc
 pop af
 ret
#endlocal
endsub showhex

defsub showhex1
#local
 cp 10
 jp nc, els
 add a,48
 jp wrt
 els:
 add a,65-10
 jp wrt
#endlocal
endsub showhex1


defsub abort
 call wrt
 db 018h,0feh
endsub abort

defsub trace.s
 push af
 push hl
 ld a,(trad)
 ld hl,1ae0h
 call wrt
 call 4dh
 inc a
 ld (trad),a
 ld a,32
 call wrt
 pop hl
 pop af
endsub trace.s
defwork trad
 db 65
endwork trace.s

defsub showz
 push af
 jr z,showz.s
 ld a,'N'
 call wrt
 showz.s:
 ld a,'z'
 call wrt
 ld a,32
 call wrt
 pop af
endsub showz


defsub showc
 push af
 jr c,showc.s
 ld a,'N'
 call wrt
 showc.s:
 ld a,'c'
 call wrt
 ld a,32
 call wrt
 pop af
endsub showc

defwork cursor
 dw 1800h
endwork cursor

defsub wrt
#local
 push hl
 push af
 ld hl,(cursor)
 call 4dh
 inc hl
 ld a,h
 cp 1bh
 jr c,sk
  ld h,18h
 sk:
 ld (cursor),hl
 pop af
 pop hl
 ret
#endlocal
endsub wrt

defsub print.a
 ld a,(hl)
 cp 0
 ret z
 call wrt
 inc hl
 jr print.a
endsub print.a

defsub unreach.new
 ld hl,unreach.m
 call print.a
 pop hl
 show hl
 db 18h,0feh
 unreach.m:
 db "unreach"
 db 0
endsub unreach.new
unreach.new.init macro xx
ld hl,h.unreach
ld (hl),0c3h
ld hl,unreach.new
ld (h.unreach+1),hl
endm`,
    'z_sp':`include z_mem
include z_debug
sp.get macro
 ld HL,0
 ADD hl, sp
endm
sp.set macro
 ld sp,hl
endm
mem2sp macro
 ;(hl)->sp
#local
 ld (rs-2),hl
 ld sp,(0)
 rs:
#endlocal
endm
sp2mem macro
 ;sp->(hl)
#local
 ld (spad-2),hl
 ld (0),sp
 spad:
#endlocal
endm

showsp macro
 ld (sptmp),sp
 showm sptmp
endm
sptmp:
dw 0
showstk macro
 showsp
 ld (sva),a
 ld a,":"
 call wrt
 ld a,(sva)
 ex (sp),hl
 show hl
 ex (sp),hl
endm
sva: db 0`,
    'z_oop':`include z_mem
include z_th
include z_assert

;a2 a1  oldpc oldix lcl1 lcl2
argidx equ 2
getarg macro n
 ld l,(ix+argidx+&n*2)
 ld h,(ix+argidx+&n*2+1)
endm
setarg macro n
 ld (ix+argidx+&n*2),l
 ld (ix+argidx+&n*2+1),h
endm

setlcl macro n
 ld (ix-(&n*2-1)),h
 ld (ix-&n*2),l
endm

getlcl macro n
 ld h,(ix-(&n*2-1))
 ld l,(ix-&n*2)
endm

addarg macro
 push hl
; hl=arg  stktp=af
;ex (sp),hl
;ld a,h
;push af
endm



pusharg macro n
 getarg &n
 push HL
endm

pushlcl macro n
 getlcl &n
 push HL
endm


pops macro n
 rept &n*2
  inc sp
endm
endm



pushthis macro xx
 getthis &xx
 push af
endm
popthis macro xx
 popa &xx
 ld (this),a
endm


invoketg.a macro fld
; pushthis before arg push
; hl=target
 ld a,h
 ld (this),a
 getfld &fld
 callhl
; pops args
; popthis after
endm

invoke macro fld
 getfld &fld
 callhl
; pops args
 getthis 0
endm

getfld macro n
#local
 ld (ad-1),a
 ld hl,(&n)
 ad:
#endlocal
endm

setfld macro n
#local
 ld (ad-1),a
 ld (&n),hl
 ad:
#endlocal
endm

getfldtg macro n
;hl=tg
 ld l,&n
 peekw hl,hl
endm

setfldtg macro n
; stk=val hl=tg
 ld l,&n
 pop de
 pokew hl,de
endm

getfldtg_botu macro n
; hl=target
 ld d,h
 ld e,&n
 peekw HL,de
endm

tgconst macro n
 ld (&n-1),a
endm
tgconst.g macro r16,n,fld
 ld &r16,(&fld)
 &n:
endm
tgconst.s macro n,fld,r16
 ld (&fld),&r16
 &n:
endm


curth2this macro
 ld a,(th.cur+1)
 ld (this),a
endm
getthis macro xx
 ld a,(this)
endm

new macro Class,flds,st,en
 th.new.range th.start+&st*th.size, th.start+&en*th.size
 pushi &flds, bc
 pushi &Class, bc
 call o.new
endm

defsub o.new
#local
 ; {val .f} n &initbl retad
 pop hl;retad
 ld (retad-2),hl
 ; set initbl for th.with
 pop hl;&initbl
 th.with.setdst hl
 ; save this
 ld (svthis-1),a
 ; allocate thread
 call th.new
 jr nc, allocfail
 push hl; thread address
 call th.with.s; call &initbl
 pop hl; thread address
 ld a,h; set this as thread
 ; init fields
 pop bc; n of {val .f}
 inc c
 loop:
  dec c
  jr z,lpend
  pop hl; .f
  ld h,a
  ld (w-2),hl
  pop hl; val
  ld (w),hl
  w:
 jr loop
 lpend:
 ; return h as this
 ld h,a
 finally:
  ;restore a before call o.new
  ld a,0
  svthis:
  ;return
  jp 0
  retad:
 allocfail:
  ; drop {val .f}
  pop bc; n of {val .f}
  ld b,c
  inc c
  lp2:
   dec c
   jr z, lp2end
   pop hl
   pop hl
  jr lp2
  lp2end:
  ld hl,null;  todo null
  jr finally
#endlocal
endsub o.new

new.arg.i macro n,v
 ld hl,&v
 new.arg &n
endm
new.arg macro n
 push hl
 pushi &n,bc
endm

o.assert.eq macro fld,v
#local
 assert.do aa
  getfld &fld
  assert.eq &v
  ret
 aa:
#endlocal
endm

this:
db 0

fld.def macro n
 &n equ fldidx
 fldidx:defl fldidx-2
endm
class macro Class,super
 unreach "c"
 marker.b 0
 dw &super
 fldidx:defl fld.top
 &Class:
  fld .class,&Class
endm
fld.bottom macro Class
 if 0
  if bottomOf&Class ne fldidx
   .error bottom ne fldidx
  endif
 else
 bottomOf&Class:defl fldidx
 endif
endm
fld macro n,v
 if 0
  if &n ne fldidx
   .error &n ne fldidx
  else
   fldidx:defl fldidx-2
  endif
 else
  fld.def &n
 endif
 pushi &v,bc
endm
unuse macro xx
 fldidx:defl fldidx-2
 pushi 0,bc
endm
meth macro Class,n
 fld .&n, &Class.&n
endm
met2 macro Class,n
 fld &n, &Class&n
endm

class Object,null
 fld .main,null
 fld.bottom Object
 marker.e Object


defsub o.boot
 curth2this
 invoke .main
endsub o.boot


yield macro
 pushthis 0
 push ix
 call th.yield
 pop ix
 popthis 0
endm

def.noent: defl 0
def macro n,args,lcls
head &n
 def.args:defl &args
 def.locals:defl &lcls
 if def.noent eq 0
  enter &lcls
 endif
endm
enter macro locals
 ;  arg2 arg1 retad oldix lcl1 lcl2
 push ix
 ld ix,0
 add ix,sp
 rept &locals
  push HL
endm
endm
enddef macro n
 if def.noent eq 0
  exit def.args
 else
  ret
 endif
 marker.e &n
endm
exit macro n
 ld sp,ix
 pop ix
 if &n!=0
  exx
  pop bc
  pops &n
  push bc
  exx
 endif
 ret
endm


defsub isobj.a
 ;hl=obj?
 ;cy=true
 ld a,h
 cp th.start.h
 jr c,notobj
 cp th.end.h
 jr nc,notobj
 scf
 ret
 notobj:
 and a
endsub isobj.a

defsub instanceof
 ; a=this de=Class
 ; z: true
 getfld .class
 jp is.subclass.a
endsub instanceof

defsub get.superclass
 ; hl=Class
 dec hl
 dec hl
 peekw hl,hl
endsub get.superclass

defsub is.subclass.a
#local
 ; hl=Subclass
 ; de=Superclass
 ; z:true
 top:
 cpde.a 0
 ret z
 call get.superclass
 push de
 ld de,null
 cpde.a 0
 pop de
 jr nz,top
 cpde.a 0
#endlocal
endsub is.subclass.a
`,
    'z_spr':`include z_const
include z_th
include z_mem
include z_oop
include z_sub

class Sprite,Object
 fld .main, 0
 fld.bottom Object
 fld .x, 100
 fld .y, 100
 fld .p, 0
 fld .c, 2
 fld.bottom Sprite
 marker.e Sprite

outwrt macro n
  out (98h),a
endm


spr.unscale macro n
 ; HL -> A
 rept spr.scale
  srlhl 0
endm
 LD A,L
endm

defsub spr.puts_old
#local
 ld hl, 1b00h
 call SETWRT
 th.for.a sprl, 0, th.count
  ld a,h
  tgconst t1
  tgconst t2
  tgconst t3
  tgconst t4

  tgconst.g hl,t1,.y
  spr.unscale 0
  sub 8
  outwrt 0

  tgconst.g hl,t2,.x
  spr.unscale 0
  sub 8
  outwrt 0

  tgconst.g a,t3,.p
  sla a
  sla a
  outwrt 0

  tgconst.g a,t4,.c
  outwrt 0
  continue
 sprl:
#endlocal
endsub spr.puts

defsub spr.puts
#local
 call spr.putslp
 ld a,(spr.puts.s)
 cp 1
 jr nz,rdir
  ld a, th.count-1
  ld (spr.puts.s),a
  ret
 rdir:
 ld a,1
 ld (spr.puts.s),a

 ld a,(spr.puts.b)
 inc a
 cp th.end.h
 jr c,rsta
  sub th.count
 rsta:
 ld (spr.puts.b),a
#endlocal
endsub spr.puts_new

defwork spr.puts.b
 db th.start.h
endwork spr.puts.b

defwork spr.puts.s
 db 1
endwork spr.puts.s

defsub spr.putslp
#local
 ld hl, 1b00h
 call SETWRT
 ld a, (spr.puts.b)
 ld b, th.count
 sprl:
  call spr.put1
  ld c,a
  ld a,(spr.puts.s)
  add a,c
  cp th.end.h
  jr c,nrst
   sub th.count
  nrst:
 djnz sprl
 ld a,208
 outwrt 0
#endlocal
endsub spr.putslp


defsub spr.put1
; a: th.id
#local
  push af

  tgconst t1
  tgconst t2
  tgconst t3
  tgconst t4
  ld h,a
  call th.isblank.a
  jr z,nothave

  tgconst.g hl,t1,.y
  spr.unscale 0
  sub 8
  outwrt 0

  tgconst.g hl,t2,.x
  spr.unscale 0
  sub 8
  outwrt 0

  tgconst.g a,t3,.p
  sla a
  sla a
  outwrt 0

  tgconst.g a,t4,.c
  outwrt 0
  nothave:
  pop af
#endlocal
endsub spr.put1

`,
    'z_sprpat':`include z_const

;aaa
spr.inipat:
 ld de,3800h
 ld hl,spr.pat
 ld bc,128
 jp LDIRVM
bg.inipat:
 ret
spr.pat:
; --- Slot 0 cat fstand
; color 9
DB $0C,$0E,$0F,$4F,$3D,$1D,$7F,$1B
DB $0C,$3F,$7F,$7F,$6F,$0F,$06,$0C
DB $18,$38,$F8,$F9,$DE,$DC,$7F,$6C
DB $98,$FC,$FE,$FE,$F6,$F0,$60,$70
;
; --- Slot 1 cat fwalk1
; color 9
DB $0C,$0E,$0F,$4F,$3D,$1D,$7F,$1B
DB $0C,$3F,$7F,$7F,$EF,$EF,$06,$06
DB $18,$38,$F8,$F9,$DE,$DC,$7F,$6C
DB $98,$FC,$FE,$FE,$D4,$78,$F0,$00
;
; --- Slot 2 cat fwalk2
; color 9
DB $18,$1C,$1F,$9F,$7B,$3B,$FE,$36
DB $19,$3F,$7F,$7F,$2B,$1E,$0F,$00
DB $30,$70,$F0,$F2,$BC,$B8,$FE,$D8
DB $30,$FC,$FE,$FE,$F7,$F7,$60,$60
;
; --- Slot 3 cat omg
; color 9
DB $2C,$8E,$0F,$4B,$3D,$11,$7F,$1D
DB $CA,$FF,$7F,$3F,$15,$1F,$0E,$00
DB $1C,$39,$F8,$E9,$DE,$C4,$7F,$5C
DB $AB,$FF,$FF,$FE,$AC,$F8,$70,$00

ds 60*32, 0
`,
    'z_tnu':`
include z_spr
include z_bool
include z_key

;.onUpdate equ .c-2
;.update equ .onUpdate-2
;.screenOut equ .update-2
;.die equ .screenOut-2
;.updateEx equ .die-2

end.const macro n
 pushi RActor.wait,bc
 pushi o.boot,bc
 th.with.ret 0
 marker.e &n
endm

RActor.noovr macro Class
 meth &Class,main
 fld.bottom Object
 fld .x, 0
 fld .y, -1024
 fld .p, 0
 fld .c, 3
 fld.bottom Sprite
 meth RActor,onUpdate
 meth RActor,update
 meth RActor,screenOut
 meth RActor,die
 meth RActor,updateEx
 meth RActor,crashTo
 fld.bottom RActor
endm

class RActor,Sprite
 RActor.noovr RActor
 end.const RActor
RActor.main:
 enter 0
 exit 0
RActor.update:
 invoke .onUpdate
 yield
 ret
RActor.onUpdate:
 ret
RActor.screenOut:
#local
 getfld .x
 bit 1,h
 jr nz, true
 getfld .y
 ld de,192*2
 cpde.a 0
 getthis 0
 jr nc,true
 ld hl,0
 xor a
 ret
 true:
 ld hl,1
 scf
 ret
#endlocal
RActor.wait:
#local
 lbl:
 invoke .update
 jr lbl
#endlocal
def RActor.die,0,0
 ld h,a
 push af
 call th.kill.a
 pop af
enddef RActor.die

def RActor.updateEx,1,0
#local
; enter 0
 getarg 1
 ld b,h
 ld c,l
 reptbc n
  invoke .update
  continue
 n:
#endlocal
enddef RActor.updateEx

crashTo.size equ 8<<spr.scale


defsub crashTo.setXY
 getfld .x
 const cr.gx, hl
 getfld .y
 const cr.gy, hl
endsub crashTo.setXY


def RActor.crashTo,1,0
#local
 call crashTo.setXY
 getarg 1
 ;const cr.class,hl
 call isobj.a
 jr c, cr1
  unreach "c"
  ; "Cannot call target.crashTo(Class) "
 cr1:
  getthis 0
  call crashTo1
  flagtobool c
#endlocal
enddef RActor.crashTo

crashToClass macro Class,st,en
#local
 ; a=this
 call crashTo.setXY
 foreach.a &Class,&st,&en,nx
  call crashTo1
  break.if c
  continue
 nx:
 getthis 0
 jr c, found
  ld hl,null
 found:
#endlocal
endm

foreach.a macro Class,st,en,nxt
 th.for.a &nxt, &st, &en
  all.skip &Class
endm


all.skip.blank.self macro xx
 ; skip blank
  ; TODO th.ofs.stp
  call th.isblank.a
  continue.if z
  ; skip hl==this
  getthis 0
  cp h
  continue.if z
endm
all.skip.isnot macro Class
  ; skip object not instance of *Class*
  push hl
  ld a,h
  ld de,&Class
  call instanceof
  getthis 0
  pop hl
  continue.if nz
endm
all.skip macro Class
 all.skip.blank.self 0
 all.skip.isnot &Class
endm

defsub crashTo1
 ; call crashTo.setXY before
 ;hl=tg
 ;cy:true
 ;hl is used
 push af
 ld a,h
 tgconst cr.t1
 tgconst cr.t2
 pop af
 tgconst.g hl, cr.t1, .x
 ldconst bc, cr.gx
 subhl bc
 call abs
 ld bc,crashTo.size
 subhl bc
 ret nc

 tgconst.g hl, cr.t2, .y
 ldconst bc, cr.gy
 subhl bc
 call abs
 ld bc,crashTo.size
 subhl bc
endsub crashTo1




tnu.run macro Main,st,en
 unreach.new.init 0
 ld sp,sp.ini
 call screen1
 call screen2

 showsp
 showlb endusr
 call spr.inipat
 call bg.inipat

 ld hl,th.start
 ld (hl),0cdh
 ld de,th.start+1
 ld bc,th.size*th.count-1
 ldir

 call th.init
 ;call mus.ini
 new &Main, 0,&st ,&en
 movw (h.thlop),spr.puts
 movw (h.thent),keyall
 jp th.loop
endm

defsub all.die
#local
 pushthis 0
 th.for.a nxt, 0, th.count
  call th.isblank.a
  continue.if z
  invoketg.a .die
  continue
 nxt:
 popthis 0
#endlocal
endsub all.die

loadPage macro Class,args,st,en
call clearInterval
call all.die
new &Class,&args,&st,&en
endm

`,
    'z_key':`include z_debug

defsub keyall
;show hl
#local
 ld hl,keymat1
 ld de,keymat2
 ld bc,13
 ldir
 ld a,0
 ld hl,keymat1
 lp:
 push af
 call SNSMAT.a
 xor 255
 ld (hl),a
 pop af
 inc hl
 inc a
 cp 11
 jr c,lp
 ld a,1
 call snstk.a
 ld (hl),d
 inc hl
 ld a,2
 call snstk.a
 ld (hl),d
#endlocal
endsub keyall
defsub snstk.a
#local
 push hl
  ld e,a
  push de
   call 0d5h
  pop de
  ld c,a
  ld b,0
  ld hl,trig2mat
  add hl,bc
  ld d,(hl)
  ld a,e
  push de
   call 0d8h
  pop de
  cp 0
  jr z,skp1
  set 0,d
  skp1:
  ld a,e
  inc a
  inc a
  push de
   call 0d8h
  pop de
  cp 0
  jr z,skp2
  set 1,d
  skp2:
 pop hl
#endlocal
endsub snstk.a

defwork keymat1
ds 13, 0
endwork keymat1
defwork keymat2
ds 13, 0
endwork keymat2
defwork trig2mat
db 0

;  rdul
db 00100000b
db 10100000b
db 10000000b
db 11000000b
db 01000000b
db 01010000b
db 00010000b
db 00110000b

endwork trig2mat


defsub getkey.a
ex de,hl
ld hl,keymat1
call chkmat
ld hl,0
ret z
ld hl,keymat2
call chkmat
ld hl,1
ret z
inc hl
endsub getkey.a

defsub chkmat
push de
ld a,d
ld d,0
add hl,de
and (hl)
pop de
endsub chkmat

defsub getkey
push af
call getkey.a
pop af
endsub getkey

defsub stickX.a
#local
; a :stickid
; hl:  vec norm
 cp 0
 jr nz,nx1
  ld a,(keymat1+8)
  bit 7,a
  ret nz
  bit 4,a
  jp nz,neghl
  ld hl,0
  ret
 nx1:
 cp 1
 jr nz,nx2
  ld a,(keymat1+11)
  bit 7,a
  ret nz
  bit 4,a
  jp nz,neghl
  ld hl,0
  ret
 nx2:
 cp 2
 jr nz,nx3
  ld a,(keymat1+12)
  bit 7,a
  ret nz
  bit 4,a
  jp nz,neghl
  ld hl,0
  ret
 nx3:
 ; w 5-b4  a 2-b6  s 5-b0  d 3-b1
  ld a,(keymat1+3);d
  bit 1,a
  ret nz
  ld a,(keymat1+2);a
  bit 6,a
  jp nz,neghl
  ld hl,0
#endlocal
endsub stickX.a


defsub stickY.a
#local
; a :stickid
; hl:  vec norm
 cp 0
 jr nz,nx1
  ld a,(keymat1+8)
  bit 6,a
  ret nz
  bit 5,a
  jp nz,neghl
  ld hl,0
  ret
 nx1:
 cp 1
 jr nz,nx2
  ld a,(keymat1+11)
  bit 6,a
  ret nz
  bit 5,a
  jp nz,neghl
  ld hl,0
  ret
 nx2:
 cp 2
 jr nz,nx3
  ld a,(keymat1+12)
  bit 6,a
  ret nz
  bit 5,a
  jp nz,neghl
  ld hl,0
  ret
 nx3:
 ; w 5-b4  a 2-b6  s 5-b0  d 3-b1
  ld a,(keymat1+5);s
  bit 0,a
  ret nz
  bit 4,a ; w
  jp nz,neghl
  ld hl,0
#endlocal
endsub stickY.a


`,
    'z_map':`include z_sub
include z_math
include z_tnu

defsub map.adr
 ; hl=chipx
 ; de=chipy
 rept 5
  slde 0
endm
 add hl,de
 ld de,1800h
 add hl,de
endsub map.adr

defsub map.set.a
 ;  a=data
 call map.adr
 call 4dh
endsub map.set.a

defsub map.get.a
 call map.adr
 call 4ah
endsub map.get.a

defsub map.adrat.a
 ; hl=spr_x
 ; de=spr_y
 spr.unscale 0
 srl a
 srl a
 srl a
 push af
 ex de,hl
 spr.unscale 0
 srl a
 srl a
 srl a
 ld d,0
 ld e,a
 pop hl
 ld l,h
 ld h,0
 call map.adr
endsub map.adrat.a

defsub map.getat.a
 call map.adrat.a
 call 4ah
endsub map.getat.a

defsub map.setat.a
 ; a=data
 push af
 call map.adrat.a
 pop af
 call 4dh
endsub map.setat.a

defsub locate
 ; hl=chipx
 ; de=chipy
 call map.adr
 ld (cursor),hl
endsub locate
`,
    'z_maze':``,
    'z_t1':`org 09000h
jp main
include z_const
include z_ctrl
include z_math
include z_debug
include z_sub
include z_mem
include z_tnu
include z_sp

;===your code

right:dw 0

main:
tnu.run Main,0,16
def Main.main,0,0
new.arg.i .vx,1
new.arg.i .vy,0
new.arg.i .x,0
new.arg.i .y,100
new Cat,4,0,16

new.arg.i .x,100
new.arg.i .y,100
new Target,2,0,16

ld (right),hl
ld a,h
ld de,RActor
call instanceof
call showz

ld a,(right+1)
ld de,Target
call instanceof
call showz

ld a,(right+1)
ld de,Cat
call instanceof
call showz


ld hl,1
setfld .c
enddef 0

class Main,RActor
 RActor.noovr Main
 end.const Main
class Target,RActor
 RActor.noovr Target
 met2 Target,.push
 end.const Target
def Target.main,0,0
enddef Target.main
class Cat,RActor
 RActor.noovr Cat
 fld .vy, 0
 fld .vx, 0
 fld.bottom Cat
 end.const Cat
def Cat.main,0,0
 blp:
  ld hl,0108h
  call getkey
  jpf nomov
  getthis 0
  ;x+=vx
  getfld .x
  ex de, hl
  getfld .vx
  add hl,de
  setfld .x
  nomov:
  ; y+=vy
  getfld .y
  ex de, hl
  getfld .vy
  add hl,de
  setfld .y
  ld hl,(right)
  push hl
  invoke .crashTo
  jpf cr
   ; r.x+=10
   ld hl,(right)
   getfldtg .x
   ld de,10
   add hl,de
   push hl
   ld hl,(right)
   setfldtg .x
   ; r.push()
   pushthis 0
   ld hl,(right)
   invoketg.a .push
   popthis 0
  cr:
  invoke .update
 jp blp
enddef Cat.main
; test t1
def Target.push,0,0
 ld hl,3
 setfld .p
 repti 30,pse
  getfld .x
  inc hl
  setfld .x
  invoke .update
  continue
 pse:
 ld hl,0
 setfld .p
enddef Target.push

endusr:
include z_sprpat

end main
https://msxpen.com/codes/-N6DDfMvZq9aUeJ9JLpN
https://msxpen.com/codes/-N6QGYk-rr5iDuTtHpF7`,
    'z_t2':`org 8000h
include z_debug
main:
unreach.new.init 0

unreach 0
end main`,
    'z_t3':`org 09000h

include z_tnu
include z_mus
include z_sprpat

;===your code

main:
ld sp,(8000h)

call screen1

showsp
showlb endusr

ld hl,8000h
ld (hl),0cdh
ld de,8001h
ld bc,th.size*th.count-1
ldir


call th.init
call spr.inipat
;call mus.ini


new Main, 0,0,16
show hl


movw (h.thlop),spr.puts
jp th.loop

class Main, RActor
 meth Main,main
 fld.bottom Object
 fld .x,100
 fld .y,300
 fld .p,0
 fld .c,3
 fld.bottom Sprite
 meth RActor,onUpdate
 meth RActor,update
 meth RActor,screenOut
 meth RActor,die
 meth RActor,updateEx
 meth RActor,crashTo
 fld.bottom RActor
 fld.bottom Main
 end.const

Main.main:
 olp:
  getthis 0
  invoke .update
  call xrnd.a
  ld a,h
  and 15
  jr nz,doap
   getthis 0
   getfld .x
   new.arg .x
   getfld .y
   new.arg .y
   ld hl,7
   call rnd.a
   ld de,3
   sbc hl,de
   new.arg .vx
   ld hl,5
   call rnd.a
   ld de,15
   sbc hl,de
   new.arg .vy
   new Bullet, 4,0,16
   call dstk
  doap:
  ld a,8
  call SNSMAT.a
  and 1
  jr z,golf

  getthis 0
  getfld .x
  inc hl
  inc hl
  setfld .x
  ld de,400
  cpde.a 0
  jp c, olp
  golf:
  ld hl,0
  getthis 0
  setfld .x
 jp olp


class Bullet,RActor
 meth Bullet,main
 fld.bottom Object
 fld .x, 0
 fld .y, 0
 fld .p, 2
 fld .c, 15
 fld.bottom Sprite
 meth RActor,onUpdate
 meth RActor,update
 meth RActor,screenOut
 meth RActor,die
 meth RActor,updateEx
 meth RActor,crashTo
 fld.bottom RActor
 fld .vy, -10
 fld .vx, 0
 fld.bottom Bullet
 end.const

Bullet.main:
 blp:
  getthis 0
  ;x+=vx
  getfld .x
  ex de, hl
  getfld .vx
  add hl,de
  setfld .x
  ; y+=vy
  getfld .y
  ex de, hl
  getfld .vy
  add hl,de
  setfld .y
  getfld .vy
  inc hl
  setfld .vy

  invoke .update
  invoke .screenOut
  jp c, bdie
  getfld .vy
  bit 7,h
  jr nz,blp
  ld de,5
  cpde.a 0
  jr c,blp

  call dstk
  getthis 0
  ld hl,3
  setfld .p
  pushi 10,bc
  invoke .updateEx

 bleft:
  getthis 0
  ld hl,2
  setfld .p
  getfld .x
  dec hl
  dec hl
  setfld .x
  getfld .y
  dec hl
  setfld .y
  invoke .update
  invoke .screenOut
  jr c, bdie
  jr bleft
 bdie:
  invoke .die
  ret


dstk:
 push af
 ld hl,th.start+256*3
 getthis 0
 ld h,a
 ld de,1900h
 ld bc,256
 call LDIRVM
 pop af
 ret

endusr:
end main`,
    'z_t4':`org 09000h
jp main
include z_const
include z_ctrl
include z_math
include z_debug
include z_sub
include z_mem
include z_tnu
include z_sp

;===your code

right:dw 0

main:
tnu.run Main
def Main.main,0,0
new.arg.i .vx,1
new.arg.i .vy,0
new.arg.i .x,0
new.arg.i .y,100
new Cat,4,0,16

new.arg.i .x,100
new.arg.i .y,100
new Target,2,0,16

new.arg.i .x,200
new.arg.i .y,100
new Target,2,0,16


new.arg.i .x,150
new.arg.i .y,100
new.arg.i .c,8
new NTarget,3,0,16

ld (right),hl
ld a,h
ld de,Actor
call instanceof
call showz

ld a,(right+1)
ld de,Target
call instanceof
call showz

ld a,(right+1)
ld de,Cat
call instanceof
call showz


ld hl,1
setfld .c
enddef 0

class Main,Actor
 Actor.noovr Main
 end.const 0
class Target,Actor
 Actor.noovr Target
 met2 Target,.push
 end.const 0
class NTarget,Actor
 Actor.noovr NTarget
 end.const 0
def NTarget.main,0,0
 ret
enddef NTarget.main

def Target.main,0,0
enddef Target.main
class Cat,Actor
 Actor.noovr Cat
 fld .vy, 0
 fld .vx, 0
 fld.bottom Cat
 end.const 0
def Cat.main,0,0
 blp:
  getthis 0
  ;x+=vx
  getfld .x
  ex de, hl
  getfld .vx
  add hl,de
  setfld .x
  ; y+=vy
  getfld .y
  ex de, hl
  getfld .vy
  add hl,de
  setfld .y
  ld hl,Target
  push hl
  invoke .crashTo
  jpf cr
   ; r.x+=10
   const setg,hl
   getfldtg .y
   ld de,30
   add hl,de
   push hl
   ldconst hl,setg
   setfldtg .y
  cr:
  invoke .update
 jp blp
enddef Cat.main
def Target.push,0,0
 ld hl,3
 setfld .p
 repti 30,pse
  getfld .y
  inc hl
  setfld .y
  invoke .update
  continue
 pse:
 ld hl,0
 setfld .p
enddef Target.push

endusr:
end main
https://msxpen.com/codes/-N6DDfMvZq9aUeJ9JLpN
https://msxpen.com/codes/-N6QGYk-rr5iDuTtHpF7`,
    'z_t5':`org 9000h


include z_key

main:
call keyall
ld hl,0108h
call getkey
show hl
ld hl,0107h
call getkey
show hl


halt
jp main`,
    'z_gen':`org 09000h
include z_debug
include z_map
include z_math
include z_dac

main:
 ld hl,10
 ld de,10
 call locate

 ld a,35
 ld (strbuf.i),a
 ld a,0
 ld (strbuf.i+1),a
 ld hl,strbuf.i
 call print.a
  
 ld hl,12345
 call printi.a
mlp:
 jp mlp
 
 
endusr:
spr.inipat:
bg.inipat:
ret

end main`,
    'z_dac':`
;jp main
include z_const
include z_ctrl
include z_math
include z_debug
include z_sub
include z_mem
include z_th


DECSUB equ 268CH;DAC ← DAC-ARG
DECADD equ 269AH;DAC ← DAC+ARG
DECNRM equ 26FAH;DAC を正規化する (*1)
DECROU equ 273CH;DAC を四捨五入する
DECMUL equ 27E6H;DAC ← DAC*DAC
DECDIV equ 289FH;DAC ← DAC/DAC
MAF equ 2C4DH;ARG ← DAC
MAM equ 2C50H;ARG ← [HL]
MOV8DH equ 2C53H;[DE] ← [HL]
MFA equ 2C59H;DAC ← ARG
MFM equ 2C5CH;[HL] ← DAC
MMF equ 2C67H;[HL] ← DAC
MOV8HD equ 2C6AH;[HL] ← [DE]
XTF equ 2C6FH;[SP] ←→ DAC
PHA equ 2CC7H;ARG → [SP]
PHF equ 2CCCH;DAC → [SP]
PPA equ 2CDCH;[SP] → ARG
PPF equ 2CE1H;[SP] → DAC
PUSHF equ 2EB1H;DAC → [SP]
MOVFM equ 2EBEH;DAC ← [HL]
MOVFR equ 2EC1H;DAC ← (CBED)
MOVRF equ 2ECCH;(CBED) ← DAC
MOVRMI equ 2ED6H;(CBDE) ← [HL]
MOVRM equ 2EDFH;(BCDE) ← [HL]
MOVMF equ 2EE8H;[HL] ← DAC
MOVE equ 2EEBH;[HL] ← [DE]
VMOVAM equ 2EEFH;ARG ← [HL]
MOVVFM equ 2EF2H;[DE] ← [HL]
VMOVE equ 2EF3H;[HL] ← [DE]
VMOVFA equ 2F05H;DAC ← ARG
VMOVFM equ 2F08H;DAC ← [HL]
VMOVAF equ 2F0DH;ARG ← DAC
VMOVMF equ 2F10H;[HL] ← DAC

VALTYP equ 0F663H;1
DAC equ 0F7F6H;16
ARG equ 0F847H;16
FOUT equ 3425H
PUFOUT equ 3426H

defsub int2dac
 push af
 ld a,2
 ld (VALTYP),a
 ld (DAC+2),HL
 pop af
endsub int2dac
;===your code

#local
main:
ld hl,12345
call int2dac
ld hl,str
call FOUT

ld b,10
reptb nxt
 ld a,(hl)
 cp 0
 break.if z
 call wrt
 inc hl
 continue
nxt:
ret
str:
#endlocal
defsub myfout.a
#local
 xor a
 ld (strbuf.i+1),a
 bit 7,h
 jr z, posi
nega:
 neghl.sv 0
 ld a, '-'
 ld (strbuf.i),a
 jr loop
posi:
 ld a, ' '
 ld (strbuf.i),a
loop:
 ld de,10
 call udiv.a
 ;show bc
 ; bc=q hl=r
 ld a,l
 push bc
 call unshift.sbuf
 pop hl
 add a,'0'
 ld (strbuf.i+1),a
 ld a,h
 or l
 jr nz, loop
 
#endlocal
endsub myfout.a

defsub printi.a
 ;call int2dac
 call myfout.a
 ld hl,strbuf.i
 ;ld a,128
 ;ld b,0
 ;call FOUT
 call print.a
endsub printi.a
; 0123456
; s12345
;       
defsub unshift.sbuf
 ld hl, strbuf.i+5
 ld de, strbuf.i+6
 ld bc, 5
 lddr
endsub unshift.sbuf

defwork strbuf.i
ds 16, 0
endwork strbuf.i
`,
    'z_setvrm':`org 09000h
jp main
include z_const
include z_ctrl
include z_math
include z_debug
include z_sub
include z_mem
include z_th

;===your code

main:
ld hl,1800h
call SETWRT
ld a,35
repti 5, ed
inc a
out (98h),a
continue
ed:
ret`,
    'z_assert':`include z_mem
include z_math
include z_debug

a.reg.trc:
dw 0
a.reg.adr:
dw 0
a.reg.min:
dw 0
a.reg.val:
dw 0
a.reg.max:
dw 0
a.regi macro n,v
 push hl
 ld hl,&v
 ld (a.reg.&n),hl
 pop hl
endm
a.regr macro n,v
 ld (a.reg.&n),&v
endm

a.dummy macro
#local
#endlocal
endm


assert.eq macro o
 storelastpc
 pushall
 a.regi val, &o
 ld de,(a.reg.val)
 ld(a.reg.val),hl
 ld(a.reg.min),de
 ld(a.reg.max),de
 cpde
 jp nz,assert.fail
 popall
endm

assert.do macro nx
 storelastpc
 pushall
 call to
 popall
 jr &nx
 to:
endm

storelastpc macro
 push hl
 call getpc
 ld (lastpc),hl
 pop hl
endm
lastpc:
 dw 0

getpc:
 pop hl
 push hl
 ret

assert.fail:
 ld hl,0deadh
 show hl
 showm a.reg.trc
 showm a.reg.min
 showm a.reg.val
 showm a.reg.max
 showm a.reg.adr
 showm lastpc
 call freeze
assert.meqw macro ad,val
 a.regi adr,&ad
 push hl
 ld hl,(&ad)
 assert.eq &val
 pop hl
endm
`,
    'z_stksz':`org 09000h
jp main
include z_const
include z_ctrl
include z_math
include z_debug
include z_sub
include z_mem
include z_th


;===your code

sz equ 256

main:
ld hl,0fd9fh
ld (hl),0c9h
 rept sz/2
  push hl
endm
 rept sz/2
  pop hl
endm

loop:
 getsp
 ld de,-sz
 add hl,de
 ld de,1800h
 ld bc,sz
 call LDIRVM
 ld hl,0
 halt
 jp loop


`,
    'z_vdp':`;https://www.msx.org/wiki/VDP_Status_Registers
;st 0 bit 7
;read 1

;https://www.msx.org/wiki/VDP_Mode_Registers
;ctrl 1 bit 5 set 0
include z_const
include z_ctrl
;include th

defsub susint
 ld a,(RG1SAV)
 res 5,a
 ld b,A
 ld c,1
 jp WRTVDP
endsub susint
defsub rstint
 ld a,(RG1SAV)
 set 5,a
 ld b,A
 ld c,1
 jp WRTVDP
endsub rstint
defsub inted
 call RDVDP
 bit 7,a
endsub inted
doint:
 call inted
 jr z, norst
 ld hl,timecnt
 inc (hl)
 call h.tntimi
 norst:
 ;call rstint
 ret
h.tntimi:
 call int.nop
 ret
defsub setInterval
 ld (h.tntimi+1), hl
endsub setInterval
defsub clearInterval
 ld hl, int.nop
 jp setInterval
endsub clearInterval

defsub int.nop
ret
endsub int.nop

timecnt:
db 0
vdptest macro
#local
stk1:
 ds 256,35
stk2:
 ds 256,42
stk3:

vl:
 call susint
 ld sp,stk2
 ld hl,stk1
 ld de,1800h
 ld bc,256
 call LDIRVM


 ld sp,stk3
 call doint
 ld hl,stk2
 ld de,1900h
 ld bc,256
 call LDIRVM
 jp vl
#endlocal
endm

screen1:
 ld a,1
 call CHGMOD
 ld a,(RG1SAV)
 set 1,a
 ld b,A
 ld c,1
 call WRTVDP
 ret

defsub screen2
 ;ld a,2
 ;call CHGMOD
 call 72h
 ld a,(RG1SAV)
 set 1,a
 ld b,A
 ld c,1
 call WRTVDP
endsub screen2
`,
    'z_mus':`include z_mem
include z_debug
mus.ini:
 di
 ld hl,0fd9fh
 ld (hl),0c3h
 movw (0fd9fh+1),mus
 ei
 ret
mus:
#local
 push af
 push de
 ld a,(we-1)
 xor 15
 ld (we-1),a
 ld a,8
 ld e,15
 we:
 call WRTPSG
 pop af
 pop de
 ret
#endlocal

defsub mus.scale.a
 ; a: 0,1,2 ch
 ; l: 0-95
 sla a
 sla l
 ld h,0
 ld bc,scltbl
 add hl,bc
 ld e,(hl)
 call WRTPSG
 inc hl
 ld e,(hl)
 inc a
 call WRTPSG
endsub mus.scale.a

defwork scltbl
dw 0d5dh, 0c9ch, 0be7h, 0b3ch, 0a9bh, 0a02h, 0973h, 08ebh, 086bh, 07f2h, 0780h, 0714h, 06afh, 064eh, 05f4h, 059eh, 054eh, 0501h, 04bah, 0476h, 0436h, 03f9h, 03c0h, 038ah, 0357h, 0327h, 02fah, 02cfh, 02a7h, 0281h, 025dh, 023bh, 021bh, 01fdh, 01e0h, 01c5h, 01ach, 0194h, 017dh, 0168h, 0153h, 0140h, 012eh, 011dh, 010dh, 0feh, 0f0h, 0e3h, 0d6h, 0cah, 0beh, 0b4h, 0aah, 0a0h, 097h, 08fh, 087h, 07fh, 078h, 071h, 06bh, 065h, 05fh, 05ah, 055h, 050h, 04ch, 047h, 043h, 040h, 03ch, 039h, 035h, 032h, 030h, 02dh, 02ah, 028h, 026h, 024h, 022h, 020h, 01eh, 01ch, 01bh, 019h, 018h, 016h, 015h, 014h, 013h, 012h, 011h, 010h, 0fh, 0eh
endwork scltbl`,
    psgdrv: `
psg.psgs equ th.start
psg.ch1 equ psg.psgs+256
psg.ch2 equ psg.ch1+256
psg.ch3 equ psg.ch2+256
psg.chs equ psg.ch3+256

defsub mus.initPSG.a
 ld a, psg.psgs >> 8
 ld (this),a
 ld hl, psg.ch1
 setfld .psgfld.ch1
 ld hl, psg.ch2
 setfld .psgfld.ch2
 ld hl, psg.ch3
 setfld .psgfld.ch3
 ld hl, psg.chs
 setfld .psgfld.chs
endsub

defsub mus.startBGM
 pushthis 0
  push hl
  ld hl, psg.psgs
  invoketg.a .psgfld.initBGM
 popthis 0
endsub
defsub mus.startSE
 pushthis 0
  push hl
  ld hl, psg.psgs
  invoketg.a .psgfld.initSE
 popthis 0 
endsub
defsub mus.stopBGM
 pushthis 0
  ld hl, psg.psgs
  invoketg.a .psgfld.stopBGM
 popthis 0 
endsub
defsub mus.step
 pushthis 0
  ld hl, psg.psgs
  invoketg.a .psgfld.step
 popthis 0 
endsub
`,
    'z_cpslt':` org 04000h
 db 41h, 42h
 dw 04010h
 ds 12,0
ramtop equ 8000h
init:
 call cpslt
 jp ramtop 
include z_mem
include z_ctrl

cpwork equ 0c000h
cplen equ 01000h
rom equ cpwork+cplen
ram equ rom+1
defsub cpslt
#local
 ld hl,4000h
 call rdslt
 ld (rom),a
 ld hl,cpwork
 call rdslt
 ld (ram),a
 ld hl,ramtop 
 loop:
  push hl
  ld a,(rom)
  ld hl,ramtop 
  call ENASLT
  pop hl
  push hl
  ld bc,cplen
  ld de,cpwork
  ldir
  ld a,(ram)
  ld hl,ramtop 
  call ENASLT
  ld hl,cpwork
  pop de
  ld bc,cplen
  ldir
  ld a,h
  cp 0c0h
  jr c,loop
 ret
#endlocal 
endsub 0

`,
};